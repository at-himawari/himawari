---
title: ブログ作るなら最初からSSGをしろ！
date: 2025-07-27T16:23:00.000+09:00
categories:
  - 技術
tags:
  - React
coverImage: https://himawari-blog-bucket.s3.ap-northeast-1.amazonaws.com/posts/images/9f3658b5-e4de-411c-9910-e0b4d976cd08-スクリーンショット
  2025-07-27 16.35.01.jpg
---
## あなたは、ITエンジニアですか？

あなたは、ITエンジニアですか？

きっと、ここでYESと答えるエンジニアは多いことでしょう。

私は、これまでいくつかの業務系アプリケーションを作ってきました。

しかし、１人で実運用に耐えられるアプリケーションを作成していなかったことと、ITエンジニアなら自身のテックブログくらい自分で作るべきだと考え、この度Himawari Projectという個人事業を始めるとともに、Webサイト兼テックブログを書くことを始めました。

拙い部分もあるかと思いますが、どうかお付き合いください。

## Webサイトの種類

一般的に見るサイトには、ソース（HTML,CSS,JavaScript)を配信する方式には、以下の３つがあるようです。

> • SPA (Single Page Application) に向いているアプリケーション: 
>
>    ◦ 管理画面系 
>
>    ◦ SEOやSNSでのシェアがそれほど重要ではない、またはURLがあまり関係ないアプリケーション。これは、SPAではHTMLの内容がどのページでも基本的に同じになり、JavaScriptでレンダリングし直すため、OGP（Open Graph Protocol）が正しく表示されない可能性があるためです。また、GoogleのクローラーはJavaScriptを解釈すると言われているものの、SEOが主要な流入経路となるサイトではリスクが残るとされています。
>
> • SSR (Server Side Rendering) に向いているアプリケーション:  
>
>   ◦ 大規模なサービス   
>
>  ◦ リアルタイム性が求められるアプリケーション    
>
> ◦ 万能型であり、従来のWebアプリケーションのあり方に近いとされています。SEOやOGPの問題がなく、ユーザーのアクセスごとに適切な情報をサーバサイドでレンダリングして返すためです。ただし、サーバの管理（デプロイ、バージョンアップ、セキュリティアップデート、メンテナンスなど）が必要となり、コストと手間がかかる点がデメリットです。
>
> • SSG (Static Site Generation) に向いているアプリケーション:    
>
> ◦ ブログ    
>
> ◦ ドキュメントサイト    
>
> ◦ 企業サイト    
>
> ◦ これらは、コンテンツが頻繁に更新されない、静的な情報中心のサイトに適しています。SSGは事前にビルド時にHTMLを生成するため、非常に高速な表示が可能であり、静的ファイルをホスティングするだけで済むためサーバの維持管理コストが低いというメリットがあります。これらの分類は、開発するWebサイトやアプリケーションの目的、コンテンツの性質、更新頻度、SEOの重要性、運用・保守のコストなどを考慮して最適な構成を選択する上で役立ちます。

私が作成するアプリケーションは、業務系アプリケーションばかりだったので、社内に閉じたものでした。しかもシェアするシチュエーションは全くありません。当然の如く今回のブログサイト制作もSPAで制作を始めてしまいました。

あ、やばいと思った読者の方。大丈夫です。まだ、間に合います（笑）

## SPAだと何がまずいのか

SNSのシェアと、SEOに圧倒的に不利です。

SPAだと、サーバーからindex.htmlがクライアント側に渡されるわけですが、同じページ内で遷移しているように見えながらも、実際には完全なページ遷移は行われません。  

 ユーザーがクリックしても、最初からHTTPリクエストを投げに行くのではなく、JavaScriptがURLを書き換え、そのURLに基づいて必要な情報だけを再度取得します。

そのため、GoogleやXのクローラーは、JavaScriptを解釈してインデックスを行うわけですが解釈はあくまで努力目標でしかなく、実際にはTOPページしかインデックスされていないというケースが大半です。

また、SPAではOpenGraph(XにURL乗せると自動でサムネとか生成してくれるやつ）に対応するのがプログラム的にもクローラー的にも難しいです。

* プログラム的に難しい

  * コンポーネント分割したアプリケーションでは、動的にmetaタグを付け替える必要がある。それをやってくれるライブラリも用意されているが、OpenGraphやクローラーに認識されるかは運ゲー。(TypeScriptもとい、JavaScript依存）
* クローラー的に難しい

  * プログラム的に難しいとほぼ同じ原理ですが、JavaScriptを多少なりとも認識していますがそれがどこまでかはわからないため、ときに他のサイトよりもSSGよりもSPAが遅いため、クローラーがタイムアウトする可能性だってあります。

上記の理由から、SEOやシェア機能に非常に悪影響を及ぼしてしまうのです。

## じゃあ、どうやってSSGするの？

### １つの失敗

読者の中には、なんでこんなことわざわざ記事にしているの？と考える人もいることでしょう。そう。私は、最初の選択を間違えたのです（笑）

業務で、Viteを使ったので何も考えずに本プロジェクトのフレームワークにもViteを採用してしまいました。Nextであれば、設定を変えるだけでSSGが可能です(これは、数多のテックブログが解説しているので省く）がViteはできません。

### 落とし穴

vite-plugin-ssrというプラグインがあるらしい。しかし、バージョンアップかなんかでVikeという名前に変更された。

やっかいなことにVikeになってからの記事はそんなに多くない。（公式的には、名前が変わっただけで、機能は何も変わっていないらしい）

### Vikeを使ってみよう

まずは、使った結果から。結論ファースト。

**ASIS**

```
.
├── .github
│   └── workflows
│       └── deploy.yml
├── public
│   ├── ...
├── src
│   ├── components
│   │   ├── Footer.tsx
│   │   ├── Header.tsx
│   │   ├── NewsSection.tsx
│   │   ├── ScrollToTop.ts
│   │   └── VideoCard.tsx
│   ├── App.css
│   ├── App.tsx
│   ├── Home.tsx
│   ├── index.css
│   ├── License.tsx
│   ├── main.tsx
│   ├── PrivacyPolicy.tsx
│   ├── ProjectPolicy.tsx
│   ├── SoftwareDevelopment.tsx
│   ├── VideoProduction.tsx
│   ├── vite-env.d.ts
│   └── YouTube.tsx
├── .gitignore
├── eslint.config.js
├── index.html
├── LICENSE
├── package-lock.json
├── package.json
├── postcss.config.js
├── README.md
├── tailwind.config.js
├── tsconfig.app.json
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts
```

**TOBE**

```
.
├── .github
│   └── workflows
│       └── deploy.yml
├── public
│   └── ....
├── scripts
│   └── generate-posts.mjs
├── src
│   ├── components
│   │   ├── Footer.tsx
│   │   ├── HatenaIcon.tsx
│   │   ├── Header.tsx
│   │   ├── MarkdownComponents.tsx
│   │   ├── NewsSection.tsx
│   │   └── VideoCard.tsx
│   ├── content
│   │   ├── blog
│   │   │   ├── article
│   │   │       ├── ...
│   ├── pages
│   │   ├── blog
│   │   │   ├── @slug
│   │   │   │   ├── +config.ts
│   │   │   │   ├── +data.ts
│   │   │   │   ├── +description.ts
│   │   │   │   ├── +onBeforePrerenderStart.ts
│   │   │   │   ├── +Page.tsx
│   │   │   │   └── +title.ts
│   │   │   ├── +config.ts
│   │   │   ├── +data.ts
│   │   │   └── +Page.tsx
│   │   ├── index
│   │   │   ├── +config.ts
│   │   │   └── +Page.tsx
│   │   ├── license
│   │   │   ├── +data.ts
│   │   │   └── +Page.tsx
│   │   ├── privacy
│   │   │   ├── +data.ts
│   │   │   └── +Page.tsx
│   │   ├── project
│   │   │   ├── +data.ts
│   │   │   └── +Page.tsx
│   │   ├── software
│   │   │   └── +Page.tsx
│   │   ├── video
│   │   │   └── +Page.tsx
│   │   ├── youtube
│   │   │   └── +Page.tsx
│   │   ├── +config.ts
│   │   ├── +Head.tsx
│   │   └── Layout.tsx
│   ├── styles
│   │   └── index.css
│   ├── types
│   │   ├── pageContext.ts
│   │   ├── pageContextPost.ts
│   │   ├── pageContextPosts.ts
│   │   └── Post.ts
├── .gitignore
├── eslint.config.js
├── LICENSE
├── package-lock.json
├── package.json
├── postcss.config.js
├── README.md
├── tailwind.config.js
├── tsconfig.json
├── tsconfig.tsbuildinfo
└── vite.config.ts
```

見ただけで、悪寒がしますね。実務だと大混乱と大遅延を巻き起こします。

詳しく何をやってるかは、公式のホームページ(<https://vike.dev/>)で翻訳をかけて見てもらうとしてここでは、何をやったかをざっくり解説します。

前提として、Vite + Reactの構成からの導入を行うものとします。



### 作業

#### インストール

```
npm i vike vike-react
```



vite.config.tsに以下の設定を加えます。

defineConfig.plugins.vike()

```
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import vike from 'vike/plugin';
import tailwindcss from 'tailwindcss'
import autoprefixer from 'autoprefixer'
import path from 'path';

export default defineConfig({
  plugins: [
    react(),
    vike(),
  ],
  css: {
    postcss: {
      plugins: [
        tailwindcss,
        autoprefixer
      ]
    }
  },
  ssr: {
    noExternal: ['tailwindcss']
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
    },
  },
});
```

css、ssr、resolveの設定はなくてももしかたら動くかも。AIに聞きまくっていたところなので不要な設定も入り込んでいるかもしれません。

#### フォルダ構成

TOBEのフォルダ構成を見ていただくと分かる通り、src/pages配下にwebページにアクセスしたときのパスとその配下に、+XXX.ts(x)というファイルがあります。

src/pages/indexだけは、webページの｢/｣にリダイレクトされます。いわゆる、ホームページをここに作っておくと良さそうです。



#### コンポーネント

ここでは、+XXX.ts(x)を解説しておこうと思います。結構複雑なので、若干正確性に欠部分がありますがご容赦ください。

先頭に+を付けて、フレームワーク側で定義されている名前をつけると、その機能として認識してくれます。

##### +Page.tsx

クライアントサイドで表示する画面を定義できます。tsxなので、基本的にReact.FCを返して終わりです。

ふつーのReactとあんまり変わりません。

サンプルコードです。

```
import Header from "../../components/Header";
import Footer from "../../components/Footer";
import ReactMarkdown from "react-markdown";
import { usePageContext } from "vike-react/usePageContext";
import { PageContext } from "../../types/pageContext";
import { markdownComponents } from "../../components/MarkdownComponents";

const License: React.FC = () => {
  const pageContext = usePageContext() as { data: PageContext };
  const content = pageContext.data?.content || "読み込み中...";
  
  return (
    <>
      <Header />
      <section id="license" className="py-12">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          <ReactMarkdown components={markdownComponents}>{content}</ReactMarkdown>
        </div>
      </section>
      <Footer />
    </>
  );
};

export default License;

```

その他、+data.tsや+onBeforeRender.tsからのデータを受け取ることができます。

##### +data.ts と +onBeforeRender.ts

サーバーサイドで実行されるデータ取得ロジックです。

例えば、データベース接続のために、SQLを投げたり（ORMでもOK）APIリクエストを投げたりして、その結果を+Page.tsxに返してあげます。

+data.tsとonBeforeRender.tsの違いは、+Page.tsxへのデータの返し方にあります。

+data.tsでは、pageContext.data.xxxに格納されるのに対して、+onBeforeRender.tsではpageContext.xxxでデータを返してあげることができます。（誰得？）

例で見てみましょう

+data.ts

```
import fs from "node:fs";
import path from "node:path";
import matter from "gray-matter";

export function data() {
  // プロジェクトのルートディレクトリからの相対パスでMarkdownファイルを読み込みます
  const filePath = path.join(process.cwd(), "src", "content", "license.md");
  const fileRawContent = fs.readFileSync(filePath, "utf-8");

  // gray-matterでファイル内容をパースし、本文(content)とフロントマター(data)を分離します
  const { content } = matter(fileRawContent);
  return {
    content, // pageContext.data.contentで+Page.tsxで受け取れます。
  };
}


```

+onBeforeRender.ts

```
// /pages/some-page/+onBeforeRender.js
 
export function onBeforeRender() {
  const someValue1 = /* ... */
  const someValue2 = /* ... */
  // pageContext.prop1 === someValue1
  // pageContext.prop2 === someValue2
  return {
    pageContext: {
      prop1: someValue1, //pageContext.prop1
      prop2: someValue2 //pageContext.prop2で受け取れます
    }
  }
}
```

pageContext以外も渡せるよ〜ってところが違いなんですかね。（使い方をよくわかっていない）

ブログサイトのSSGするなら、あまり関係ない部分だと思ってもらっていいです。基本的には+data.tsを使いましょうで済む話です。

で、+data.tsをどこで使うかと言ったら、ブログデータやらユーザデータやらがデータベースに入っている場合でしょうか。今回、リポジトリにダイレクトで突っ込んでいるので、そのあたりの技術は使いませんでした。

##### +config.ts
